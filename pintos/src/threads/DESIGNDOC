			+--------------------+
			|        CS 4100     |
	  		|       PROJECT 2    |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

Ben Byerly         bobyerly42@tntech.edu
Levi Spellmeyer    lgspellmey42@tntech.edu
Gage Jones
Nicholas Florence
Mark Weber         mpweber42@tntech.edu

---- PRELIMINARIES ---- 

>> This document describes our implementation of Alarm Clock and Basic Priority Scheduling for Pintos Project 2. 

>> PRIORITY DONATION AND MLFQS ARE NOT IMPLEMENTED YET OR BY DESIGN
>> PRIORITY MIGHT BE DONE, IM NOT SURE YET. (MARK WEBER)

ALARM CLOCK 
=================================================================================================

---- DATA STRUCTURES ----

>> in thread.h:
>> // below is to be used by sleeping threads to record the tick at when they should be unblocked. 
>> int64_t wakeup_tick; 

>> in timer.c:
>> // below is to store blocked threads and sorted by the earliest wakeup time.
>> static struct list sleep_list;

>> comparator that is used for the ordered insertionn:
>> // this purpose below is to ensure sleep_list remains sorted by the wakeup_tick
>> bool wakeup_tick_less(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED);



---- ALGORITHMS ----

+== timer_sleep(ticks): ==+
>> this calculates wakeup_tick = timer_ticks() + ticks
>> disables interrupt
>> inserts the current thread into sleep_list in sorted order. 
>> calls thread_block() to put the thread to sleep
>> restores the interrupt level

+=== timer_interrupt() ==+
>> Everything below happens at each tick
>> increments global ticks
>> calls thread_tick()
>> checks the front of the sleep_list
>> while the earliest thread's wakeup_tick <= ticks
>>   it will remove it from sleep_list
>>   and call thread_unblock(thread)
>> since the list is sorted, only the front needs to be checked. helps with compute. 



---- SYNCHRONIZATION ----

>> sleep_list is always acessed with interrupts disabled
>> this will prevent some race conditions between the following:
>>   inserting sleeping threads
>>   waking threads in the interrupt handler
>> thread-block() and thread_unblock() alredy need to have interrupts off

>> this will guarantee:
>>   ordering of wakeups
>>   no missed wakeups
>>   no reordering of any sleeping threads
>> no edge cases where an idle thread is not inserted into sleep_list

----RATIONALE ----

>> Advantages
>>   sorted insertion makes sure that the wakeups are O(1) because only head needs to be checked
>>   simple and efficient compared to scanning the list at each tick
>>   few code changes to the OG structure

>> Disadvantages
>>   sorted insertion makes it O(n) since it is linear function: list_insert_ordered()
>>   priority queue or binary would is more efficient 
=================================================================================================
 


PRIORITY SCHEDULING
=================================================================================================

---- DATA STRUCTURES ---- 
>> no new stuct were required except: int base_priority;
>> purpose is a place holder for work done with donation in the future


---- ALGORITHMS ----

>> Ready List Ordering
>> ready_list is always kept sorted by priority by using:
>>   bool thread_priority_compare(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED);
>> this is used in thread_unblock() and thread_yield()
>> thread_unblock()
>>   interrupts the disabled
>>   inserts thread ready into ready list sorted by prio
>>   marks thread_ready

>> thread_yield()
>>   current thread (if not idle) gets reinserted into the ready list
>>   ready list stays sorted
>>   scheduler chooses from the front of the list

>> Preemption logic below
>> thread_create()
>>   if(t->priority > thread_current()->priority)
>>      thread_yield();
>> thread_set_priority()
>>   if(highest_ready->priority > cur->priority)
>>      thready_yield();

>> these make sure 
>>  newly created higher prio thready will preempt 
>> lowering the current thread's prio will trigger the preempt


---- SYNCHRONIZATION ----
>> all opertions that modify ready_list will occure with interrupts disabled
>> this will avoid race conditions between yield/unblock and the handler

>> edge cases
>>  idle thread is never added to ready_list
>>  no donation logic yetmeans that no recursive locking issue. 



--- RATIONALE ---- 
>> advantages
>>   basic prio scheudling
>>   matches the pintos specifications for 
>>      prio-fifo
>>      prio-preempt
>>      alarm-priority
>> scheudler always picks highest prio

>> disadvantages
>>  no prio donation yet so prio inversion isnt possible
>>  ready_list uses O(n) ordered list instead of a heap 

=================================================================================================



PRIORITY DONATION
=================================================================================================

---- DATA STRUCTURES ----

>> in thread.h:
>> // base priority is preserved so a thread can restore it after releasing locks
>> int base_priority;       
>>
>> // list of threads that have donated to this thread
>> struct list donations;   
>>
>> // list_elem used when this thread appears in another thread’s donation list
>> struct list_elem donation_elem;


---- ALGORITHMS ----

+== lock_acquire(lock *lock): ==+
>> checks if the lock is already held by another thread
>> if so:
>>   - sets current thread’s wait_lock = lock
>>   - inserts current thread into lock-holder’s donation list
>>     using list_insert_ordered() with donation priority comparator
>>   - propagates the donation through nested locking chains (max depth = 8)
>> sema_down() is called to actually acquire the lock
>> after acquiring:
>>   - wait_lock is cleared
>>   - lock->holder = current thread

+== lock_release(lock *lock): ==+
>> removes any donation entries that were made because the current thread
>> was holding this lock
>> recomputes current thread’s effective priority using:
>>   - its base_priority
>>   - remaining highest donated priority (if any)
>> lock->holder is set to NULL
>> sema_up() wakes the highest priority waiter


---- SYNCHRONIZATION ----

>> donation list modifications occur with interrupts disabled (inside sema_down/up)
>> ensures no race conditions between:
>>   - threads donating priority
>>   - threads acquiring/releasing locks
>> threads maintain wait_lock so nested donation chains can be followed reliably
>> donation removal occurs before priority refresh to avoid stale donors


---- RATIONALE ----

>> Advantages
>>   resolves priority inversion where a low-priority lock holder blocks a
>>   higher-priority thread
>>   supports nested donation (chain donation)
>>   supports multiple donors waiting on the same lock
>>   integrates cleanly with existing priority scheduler structures

>> Disadvantages
>>   donation propagation adds overhead (O(n) per insertion + chain traversal)
>>   recursion depth capped at 8 to avoid infinite loops
>>   requires careful management of donation list ordering

=================================================================================================

END OF DESIGN DOCUMENT    











