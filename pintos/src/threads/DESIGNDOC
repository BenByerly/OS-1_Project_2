			+--------------------+
			|        CS 4100     |
	  		|       PROJECT 2    |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

Ben Byerly         bobyerly42@tntech.edu
Levi Spellmeyer    lgspellmey42@tntech.edu
Mark Weber         mpweber42@tntech.edu
Gage Jones		   grjones42@tntech.edu
Nicholas Florence  ncflorence42@tntech.edu

---- PRELIMINARIES ---- 

>> This document describes our implementation of Alarm Clock and Basic Priority Scheduling for Pintos Project 2. 

>> PRIORITY DONATION AND MLFQS ARE NOT IMPLEMENTED YET OR BY DESIGN
>> PRIORITY MIGHT BE DONE, IM NOT SURE YET. (MARK WEBER)

ALARM CLOCK 
=================================================================================================

---- DATA STRUCTURES ----

>> in thread.h:
>> // below is to be used by sleeping threads to record the tick at when they should be unblocked. 
>> int64_t wakeup_tick; 

>> in timer.c:
>> // below is to store blocked threads and sorted by the earliest wakeup time.
>> static struct list sleep_list;

>> comparator that is used for the ordered insertionn:
>> // this purpose below is to ensure sleep_list remains sorted by the wakeup_tick
>> bool wakeup_tick_less(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED);



---- ALGORITHMS ----

+== timer_sleep(ticks): ==+
>> this calculates wakeup_tick = timer_ticks() + ticks
>> disables interrupt
>> inserts the current thread into sleep_list in sorted order. 
>> calls thread_block() to put the thread to sleep
>> restores the interrupt level

+=== timer_interrupt() ==+
>> Everything below happens at each tick
>> increments global ticks
>> calls thread_tick()
>> checks the front of the sleep_list
>> while the earliest thread's wakeup_tick <= ticks
>>   it will remove it from sleep_list
>>   and call thread_unblock(thread)
>> since the list is sorted, only the front needs to be checked. helps with compute. 



---- SYNCHRONIZATION ----

>> sleep_list is always acessed with interrupts disabled
>> this will prevent some race conditions between the following:
>>   inserting sleeping threads
>>   waking threads in the interrupt handler
>> thread-block() and thread_unblock() alredy need to have interrupts off

>> this will guarantee:
>>   ordering of wakeups
>>   no missed wakeups
>>   no reordering of any sleeping threads
>> no edge cases where an idle thread is not inserted into sleep_list

----RATIONALE ----

>> Advantages
>>   sorted insertion makes sure that the wakeups are O(1) because only head needs to be checked
>>   simple and efficient compared to scanning the list at each tick
>>   few code changes to the OG structure

>> Disadvantages
>>   sorted insertion makes it O(n) since it is linear function: list_insert_ordered()
>>   priority queue or binary would is more efficient 
=================================================================================================
 


PRIORITY SCHEDULING
=================================================================================================

---- DATA STRUCTURES ---- 
>> no new stuct were required except: int base_priority;
>> purpose is a place holder for work done with donation in the future


---- ALGORITHMS ----

>> Ready List Ordering
>> ready_list is always kept sorted by priority by using:
>>   bool thread_priority_compare(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED);
>> this is used in thread_unblock() and thread_yield()
>> thread_unblock()
>>   interrupts the disabled
>>   inserts thread ready into ready list sorted by prio
>>   marks thread_ready

>> thread_yield()
>>   current thread (if not idle) gets reinserted into the ready list
>>   ready list stays sorted
>>   scheduler chooses from the front of the list

>> Preemption logic below
>> thread_create()
>>   if(t->priority > thread_current()->priority)
>>      thread_yield();
>> thread_set_priority()
>>   if(highest_ready->priority > cur->priority)
>>      thready_yield();

>> these make sure 
>>  newly created higher prio thready will preempt 
>> lowering the current thread's prio will trigger the preempt


---- SYNCHRONIZATION ----
>> all opertions that modify ready_list will occure with interrupts disabled
>> this will avoid race conditions between yield/unblock and the handler

>> edge cases
>>  idle thread is never added to ready_list
>>  no donation logic yetmeans that no recursive locking issue. 



--- RATIONALE ---- 
>> advantages
>>   basic prio scheudling
>>   matches the pintos specifications for 
>>      prio-fifo
>>      prio-preempt
>>      alarm-priority
>> scheudler always picks highest prio

>> disadvantages
>>  no prio donation yet so prio inversion isnt possible
>>  ready_list uses O(n) ordered list instead of a heap 

=================================================================================================



PRIORITY DONATION
=================================================================================================

---- DATA STRUCTURES ----

>> thread.h additions:
>>   int base_priority;            // original priority
>>   int priority;                 // effective priority
>>   struct list donations;        // threads donating to this one
>>   struct list_elem donation_elem;
>>   struct lock *wait_lock;       // lock this thread is waiting on

>> synch.c (condvar support):
>>   semaphore_elem stores: elem, semaphore, int priority


---- ALGORITHMS ----

+== lock_acquire(lock): ==+
>> if lock->holder != NULL:
>>    - cur->wait_lock = lock
>>    - insert cur into holder->donations (ordered by priority)
>>    - propagate donation through wait_lock chain (depth â‰¤ 8)
>> sema_down()
>> cur->wait_lock = NULL
>> lock->holder = cur

+== lock_release(lock): ==+
>> remove donors whose wait_lock == lock
>> refresh priority = max(base_priority, remaining donations)
>> lock->holder = NULL
>> sema_up() wakes highest-priority waiter


---- PRIORITY-AWARE SEMAPHORES ----
>> sema_down(): insert into waiters ordered by priority
>> sema_up(): wake highest-priority waiter + preempt if needed


---- PRIORITY-AWARE CONDITION VARIABLES ----
>> cond_wait(): store waiter.priority, insert ordered
>> cond_signal(): wake highest-priority waiter


---- SYNCHRONIZATION ----
>> donation + semaphore operations run with interrupts disabled
>> wait_lock ensures nested donation works correctly
>> donations cleaned before priority refresh


---- RATIONALE ----

>> Advantages:
>>   - prevents priority inversion under lock contention
>>   - supports multiple donors and nested donation chains
>>   - integrates with existing priority scheduler
>>
>> Disadvantages:
>>   - list operations + donation chain traversal add O(n) overhead
>>   - depth limit needed to avoid infinite loops
>>   - correctness depends on proper ordering and cleanup of donation lists

=================================================================================================
END OF DESIGN DOCUMENT